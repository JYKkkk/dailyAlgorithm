<img src="https://j7b205.p.ssafy.io/assets/header/markdown_header.png" />

# <img src="https://static.solved.ac/tier_small/16.svg" alt="tier" height="32px" /> 가장 긴 증가하는 부분 수열 5 - 14003 

## 문제

> https://www.acmicpc.net/problem/14003

### 분류

binary_search,lis

### 문제 설명

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.



#### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)



#### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.



#### 예제

<table><tr><th><img width=120/>입력 1<img width=120/></th><th><img width=120/>출력 1<img width=120/></th></tr><tr><td>

```
6
10 20 10 30 20 50
```
</td><td>

```
4
10 20 30 50
```
</td></tr></table>


####

## 풀이 코드

```c
import sys
N = int(sys.stdin.readline())
A = list(map(int, sys.stdin.readline().split()))

# dp[i] = 길이가 i인 증가하는 부분수열이 어느 [숫자, idx]로 끝나는가
dp = [[-1_000_000_001,0] for i in range(N+1)]
# prev[i] = A[i]가 마지막인 최장 부분수열의 이전 숫자 위치
prev = [-1 for i in range(N)]

answer = 0
for n in range(N):
    if dp[answer][0] < A[n]:
        answer+=1
        dp[answer][0] = A[n]
        dp[answer][1] = n
        prev[n] = dp[answer-1][1]
    
    else:
        lo = 1
        hi = answer

        while lo<hi:
            mid = (lo+hi)//2
            if A[n] <= dp[mid][0]:
                hi = mid
            else:
                lo = mid + 1
                
        dp[hi][0] = A[n]
        dp[hi][1] = n
        prev[n] = dp[hi-1][1]

# print(dp)
# print(prev)
print(answer)

idx = dp[answer][1]
result = [A[idx]]

while idx != prev[idx]:
    idx = prev[idx]
    result.append(A[idx])

for i in range(answer-1, -1, -1):
    sys.stdout.write(str(result[i]) + " ")


```
